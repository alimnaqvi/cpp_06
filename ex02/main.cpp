#include "A.h"
#include "B.h"
#include "Base.h"
#include "C.h"
#include <exception>
#include <iostream>
#include <random>

Base* generate( void )
{
    // Seed our Mersenne Twister using a pseudo-random number generated by the OS
    std::mt19937 mt{ std::random_device{}() };

    // Create a reusable random number generator that generates uniform numbers between 1 and 3
    std::uniform_int_distribution random3{ 1, 3 };

    // Generate a random number between 1 and 3, and return instantiate the corresponding derived class
    switch ( random3( mt ) )
    {
    case 1:
        std::cout << "Instantiating A" << '\n';
        return new A;
    case 2:
        std::cout << "Instantiating B" << '\n';
        return new B;
    case 3:
        std::cout << "Instantiating C" << '\n';
        return new C;
    default: // Should never be reached but just because
        std::cout << "Instantiating Base" << '\n';
        return new Base;
    }
}

void identify( Base* p )
{
    if ( dynamic_cast<A*>( p ) )
    {
        std::cout << "Pointer identified: A" << '\n';
        return;
    }
    if ( dynamic_cast<B*>( p ) )
    {
        std::cout << "Pointer identified: B" << '\n';
        return;
    }
    if ( dynamic_cast<C*>( p ) )
    {
        std::cout << "Pointer identified: C" << '\n';
        return;
    }
    // Should never be reached but just because
    std::cout << "Pointer is neither of A, B, and C; must be Base" << '\n';
}

void identify( Base& p )
{
    try
    {
        dynamic_cast<A&>( p );
        std::cout << "Reference identified: A" << '\n';
        return;
    }
    catch ( const std::exception& )
    {
        // Ignore
    }

    try
    {
        dynamic_cast<B&>( p );
        std::cout << "Reference identified: B" << '\n';
        return;
    }
    catch ( const std::exception& )
    {
        // Ignore
    }

    try
    {
        dynamic_cast<C&>( p );
        std::cout << "Reference identified: C" << '\n';
        return;
    }
    catch ( const std::exception& )
    {
        // Ignore
    }

    // Should never be reached but just because
    std::cout << "Reference is neither of A, B, and C; must be Base" << '\n';
}

int main()
{
    Base* ptr1{ generate() };
    Base* ptr2{ generate() };
    Base* ptr3{ generate() };

    identify( ptr1 );
    identify( ptr2 );
    identify( ptr3 );

    Base& ref1{ *ptr1 };
    Base& ref2{ *ptr2 };
    Base& ref3{ *ptr3 };

    identify( ref1 );
    identify( ref2 );
    identify( ref3 );

    delete ptr1;
    delete ptr2;
    delete ptr3;

    return 0;
}
